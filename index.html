<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tower Defense Prototype</title>
  <style>
    html, body { margin:0; height:100%; background:#0e0f13; color:#e6e6e6; font:14px/1.2 system-ui, sans-serif; }
    #ui { position:fixed; left:8px; top:8px; z-index:1; }
    canvas { display:block; margin:0 auto; background:#11161d; }
  </style>
</head>
<body>
  <div id="ui">Жизни: <span id="lives">20</span> | Деньги: <span id="money">100</span> | Волна: <span id="wave">1</span></div>
  <canvas id="game" width="900" height="600"></canvas>
  <script>
  // Settings
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width *= DPR; canvas.height *= DPR; // hiDPI
  canvas.style.width = (canvas.width / DPR) + 'px';
  canvas.style.height = (canvas.height / DPR) + 'px';
  ctx.scale(DPR, DPR);

  const ui = {
    livesEl: document.getElementById('lives'),
    moneyEl: document.getElementById('money'),
    waveEl: document.getElementById('wave'),
    set() { this.livesEl.textContent = state.lives; this.moneyEl.textContent = state.money; this.waveEl.textContent = state.wave; }
  };

  // Game state
  const state = {
    lives: 20,
    money: 100,
    wave: 1,
    enemies: [],
    towers: [],
    bullets: [],
    spawn: { toSpawn: 10, interval: 1.0, timer: 0, cooldown: 2.5, betweenWaves: false },
  };

  // Path (polyline) in screen pixels
  const path = [
    {x: 40,  y: 300},
    {x: 220, y: 300},
    {x: 220, y: 120},
    {x: 520, y: 120},
    {x: 520, y: 420},
    {x: 820, y: 420},
  ];

  // Helpers
  function dist2(ax, ay, bx, by) { const dx = ax-bx, dy = ay-by; return dx*dx + dy*dy; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // Entities
  function spawnEnemy(hpMul = 1) {
    state.enemies.push({
      x: path[0].x, y: path[0].y,
      speed: 60 + Math.random()*10, // px/s
      hp: Math.floor(20 * hpMul),
      pathIdx: 1,
      radius: 10,
      reward: 5
    });
  }

  function placeTower(x, y) {
    const cost = 25;
    if (state.money < cost) return;
    // avoid placing too close to the path
    const minPathDist2 = 20*20;
    for (let i=0;i<path.length-1;i++) {
      const a = path[i], b = path[i+1];
      // point-segment distance squared
      const abx=b.x-a.x, aby=b.y-a.y;
      const t = clamp(((x-a.x)*abx + (y-a.y)*aby) / (abx*abx+aby*aby), 0, 1);
      const px = a.x + abx*t, py = a.y + aby*t;
      if (dist2(x,y,px,py) < minPathDist2) return; // too close to road
    }
    state.towers.push({
      x, y,
      range: 120,
      fireDelay: 0.35,
      cd: 0,
      bulletSpeed: 320,
      dmg: 10
    });
    state.money -= cost; ui.set();
  }

  // Input (place tower on click)
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    placeTower(x, y);
  });

  // Game loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min((now - last) / 1000, 0.033);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Spawning and waves
    const sp = state.spawn;
    if (!sp.betweenWaves) {
      sp.timer -= dt;
      if (sp.toSpawn > 0 && sp.timer <= 0) {
        spawnEnemy(1 + (state.wave-1)*0.5);
        sp.toSpawn--; sp.timer = Math.max(0.25, sp.interval - state.wave*0.05);
      }
      if (sp.toSpawn === 0 && state.enemies.length === 0) {
        sp.betweenWaves = true; sp.timer = sp.cooldown;
      }
    } else {
      sp.timer -= dt;
      if (sp.timer <= 0) {
        state.wave++;
        sp.toSpawn = 10 + Math.floor(state.wave*2);
        sp.betweenWaves = false;
      }
    }

    // Enemies move along path
    for (let i = state.enemies.length-1; i>=0; i--) {
      const e = state.enemies[i];
      const target = path[e.pathIdx];
      if (!target) {
        // reached base
        state.lives--; ui.set();
        state.enemies.splice(i,1);
        if (state.lives <= 0) resetGame();
        continue;
      }
      const dx = target.x - e.x, dy = target.y - e.y;
      const len = Math.hypot(dx, dy) || 1;
      const step = e.speed * dt;
      if (len <= step) {
        e.x = target.x; e.y = target.y; e.pathIdx++;
      } else {
        e.x += dx/len * step; e.y += dy/len * step;
      }
    }

    // Towers fire
    for (const t of state.towers) {
      t.cd -= dt;
      if (t.cd <= 0) {
        // acquire target: nearest in range
        let best = null, bestD2 = t.range*t.range;
        for (const e of state.enemies) {
          const d2 = dist2(t.x,t.y,e.x,e.y);
          if (d2 <= bestD2) { best = e; bestD2 = d2; }
        }
        if (best) {
          // fire
          const ang = Math.atan2(best.y - t.y, best.x - t.x);
          state.bullets.push({
            x: t.x, y: t.y,
            vx: Math.cos(ang)*t.bulletSpeed,
            vy: Math.sin(ang)*t.bulletSpeed,
            dmg: t.dmg,
            ttl: 2.0, // seconds
            r: 3
          });
          t.cd = t.fireDelay;
        }
      }
    }

    // Bullets update + collisions
    for (let i = state.bullets.length-1; i>=0; i--) {
      const b = state.bullets[i];
      b.x += b.vx*dt; b.y += b.vy*dt; b.ttl -= dt;
      let hit = false;
      for (let j = state.enemies.length-1; j>=0; j--) {
        const e = state.enemies[j];
        const r = e.radius + b.r;
        if (dist2(b.x,b.y,e.x,e.y) <= r*r) {
          e.hp -= b.dmg; hit = true;
          if (e.hp <= 0) {
            state.money += e.reward; ui.set();
            state.enemies.splice(j,1);
          }
          break;
        }
      }
      if (hit || b.ttl <= 0) state.bullets.splice(i,1);
    }
  }

  function drawGrid() {
    const w = canvas.width / DPR, h = canvas.height / DPR;
    ctx.save();
    ctx.strokeStyle = '#1c2631';
    ctx.lineWidth = 1;
    for (let x=0; x<w; x+=40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for (let y=0; y<h; y+=40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }

  function drawPath() {
    ctx.save();
    ctx.strokeStyle = '#6b7f99';
    ctx.lineWidth = 16; ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();
    ctx.restore();
  }

  function draw() {
    const w = canvas.width / DPR, h = canvas.height / DPR;
    ctx.clearRect(0,0,w,h);

    drawGrid();
    drawPath();

    // Towers
    for (const t of state.towers) {
      ctx.save();
      // range
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(120,180,255,0.12)';
      ctx.lineWidth = 2; ctx.stroke();

      // body
      ctx.beginPath();
      ctx.fillStyle = '#4fb4ff';
      ctx.arc(t.x, t.y, 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Enemies
    for (const e of state.enemies) {
      ctx.save();
      // hp bar
      const maxHp = 20 + (state.wave-1)*10;
      const hpRatio = Math.max(0, Math.min(1, e.hp / maxHp));
      ctx.fillStyle = '#ff4757';
      ctx.fillRect(e.x-12, e.y-18, 24, 4);
      ctx.fillStyle = '#2ed573';
      ctx.fillRect(e.x-12, e.y-18, 24*hpRatio, 4);

      ctx.beginPath();
      ctx.fillStyle = '#f0c419';
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Bullets
    ctx.save();
    ctx.fillStyle = '#ffffff';
    for (const b of state.bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // Tips
    ctx.fillStyle = '#b9c4cf';
    ctx.fillText('ЛКМ — поставить башню (25$). Не ставьте на дорогу.', 16, canvas.height/DPR - 16);
  }

  function resetGame() {
    state.lives = 20; state.money = 100; state.wave = 1;
    state.enemies.length = 0; state.bullets.length = 0; state.towers.length = 0;
    state.spawn = { toSpawn: 10, interval: 1.0, timer: 0, cooldown: 2.5, betweenWaves: false };
    ui.set();
  }

  ui.set();
  requestAnimationFrame(loop);
  </script>
</body>
</html>